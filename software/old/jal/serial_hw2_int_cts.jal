-- --------------------------------------------------------------------------
-- Title: serial_hw2_int_cts.jal. Interrupt driven buffered serial interface with flow control.
-- Author: Rob Hamerling, Copyright (c) 2008..2012, all rights reserved.
-- Adapted-by: Karl "Kiste" Seitz
-- Compiler: 2.4p
-- Revision: $Revision: 3183 $
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Serial communications for the second USART:
--   - receive and transmit data transfer is interrupt driven
--   - receive and transmit data transfer is buffered (circular buffers)
--   - provides automatic CTS flow control with spare free space for FiFo buffer
-- .
-- This library supports:
--   - Data format: 8 bits data, 1 start-bit, 1 stop bit
--   - Acceptable baud rate depends on the oscillator frequency
--     (see BAUD RATES tables in the datasheet).
--   - Interrupt bits used: TXIE, RCIE, PEIE and GIE.
-- .
-- Available procedures/functions for application programs:
-- .
--   - serial_hw2_init()                         -- initialise communications
-- .
--   - serial_send2_byte(byte out <byte>)        -- send byte
--                                               -- returns the transmitted byte
--   - serial_hw2_read(byte out <byte>) return bit  -- receive byte
--                                               -- returns TRUE with data,
--                                               -- FALSE when no data available
--   - serial_hw2_write(byte in <byte>)          -- send byte (wait if queue full)
-- .
--   - serial_hw2_data = <byte>                  -- send byte, wait if queue full
-- .
--   - serial_hw2_tx_buffer_free()               -- get free bytes in transmit buffer
--                                               -- returns number of free bytes
-- .
--   - <byte> = serial_hw2_data                  -- receive byte, wait if queue empty
-- .
-- Directions for use of this library in application programs
-- (in this sequence):
-- .
-- 1. Declare the following constant:
-- .
--      const   serial_hw2_baudrate = 115200     -- line speed
-- .
--    and variables:
-- .
--      alias serial2_ctsinv  is  pin_B4        -- incoming data flow control
--                                              -- Optional, if no CTS flow control needed
--                                              -- no dummy needs to be assigned.
-- .
--      var  bit serial2_overflow_discard       -- With transmit buffer overflow:
--                                              --   TRUE: discard data (non-blocking)
--                                              --   FALSE: wait for free space (blocking)
--                                              -- With receive buffer overflow data is
--                                              -- discarded without notification,
--                                              -- but prevented with CTS flow control,
--                                              -- provided the sender has flow control enabled
-- .
--    And optionally you could define one or more of the constants below.
--    You should do so if you want different values than shown (= defaults).
--    If not defined, the following values are used:
-- .
--      const   SERIAL2_XMTBUFSIZE  = 32        -- size of transmit buffer
--      const   SERIAL2_RCVBUFSIZE  = 64        -- size of receive buffer
--      const   SERIAL2_DELTA       = 17        -- spare space receive buffer
--                                              -- if possible keep SERIAL2_DELTA = 17!
-- .
--    When the physical locations of pin_TX2 and pin_RX2 are configurable for a specific
--    PIC, the device file will probably contain names like pin_TX2_RC2 and pin_RX2_RC1
--    and another pair with other pin suffixes.
--    Depending for which pair of pins the USART is configured aliases
--    without suffixes have to be specified, like:
--         alias  pin_TX2            is  pin_TX2_RC2
--         alias  pin_RX2            is  pin_RX2_RC1
--         alias  pin_TX2_direction  is  pin_TX2_RC2_direction
--         alias  pin_RX2_direction  is  pin_RX2_RC1_direction
-- .
-- 2. Include this library.
-- .
-- and somewhere before actually using serial communications:
-- .
-- 3. Prepare pins:
--       pin_B4_direction = OUTPUT              -- incoming data flow control
--       serial2_overflow_discard = FALSE       -- do not discard output
--    Notes: - pin_TX2 and pin_RX2 are selected automatically
--           - direction settings of these pins are taken care of by the library
-- .
-- 4. Call serial_hw2_init() to initialize serial communications.
--
-- Notes: See serial_hw_int_cts library
--
-- Sources:
--
-- ----------------------------------------------------------------------
--
-- Setup defaults when no value is specified before:
--
if (defined(SERIAL2_XMTBUFSIZE) == FALSE) then
   const   SERIAL2_XMTBUFSIZE  = 32                -- default size of transmit buffer
end if

if (defined(SERIAL2_RCVBUFSIZE) == FALSE) then
   const   SERIAL2_RCVBUFSIZE  = 64                -- default size of receive buffer
end if

if (defined(SERIAL2_DELTA) == FALSE) then
   const   SERIAL2_DELTA   = 17                    -- default spare space receive buffer
end if

if (defined(serial_hw2_baudrate) == FALSE) then
   if (defined(SERIAL2_BPSRATE) == TRUE) then
      _warn "SERIAL2_BPSRATE is deprecated - please use serial_hw2_baudrate"
      const serial_hw2_baudrate = SERIAL2_BPSRATE
   else
      _error "no baudrate defined"
   end if
end if

include usart2_common                              -- common serial functions/procedures

-- Local circular transmit buffer
var byte  _serial2_xmtbuf[SERIAL2_XMTBUFSIZE]      -- circular output buffer

-- Local circular receive buffer
var byte  _serial2_rcvbuf[SERIAL2_RCVBUFSIZE]      -- circular input buffer

-- Declaration of local offsets in circular buffers:

-- variable keeping track of next free position in transmit buffer
var volatile byte  _serial2_offsetxmthead          -- offset next byte from appl

-- variable keeping track of next byte to be transmitted by interrupt handler
var volatile byte  _serial2_offsetxmttail          -- offset next byte to port

-- variable keeping track of next free byte in receive buffer
var volatile byte  _serial2_offsetrcvhead          -- offset next byte from port

-- variable keeping track of next byte available to application program
var volatile byte  _serial2_offsetrcvtail          -- offset next byte to appl

-- Handling interrupt bits differences between PICs
if (defined(PIE3_RCIE2) == TRUE) then              -- PIE3/PIR3
   alias SERIAL2_RCIE2 is PIE3_RCIE2
   alias SERIAL2_RCIF2 is PIR3_RCIF2
   alias SERIAL2_TXIE2 is PIE3_TXIE2
   alias SERIAL2_TXIF2 is PIR3_TXIF2
elsif (defined(PIE4_RCIE2) == TRUE) then           -- PIE4/PIR4
   alias SERIAL2_RCIE2 is PIE4_RCIE2
   alias SERIAL2_RCIF2 is PIR4_RCIF2
   alias SERIAL2_TXIE2 is PIE4_TXIE2
   alias SERIAL2_TXIF2 is PIR4_TXIF2
else
   _error "Interrupt flags not found (bits not supported, please report)"
end if


-- ----------------------------------------------------------------------
-- Title:     USART serial transmit interrupt handler
-- Arguments: (none)
-- Returns:   (nothing)
-- ----------------------------------------------------------------------
procedure  _serial2_transmit_interrupt_handler() is

   pragma interrupt

   var  byte  x

   if ((SERIAL2_TXIF2 == TRUE) & (SERIAL2_TXIE2 == TRUE)) then    -- UART2 xmit interrupt
      if (_serial2_offsetxmttail != _serial2_offsetxmthead) then  -- data in xmit buffer
         x = _serial2_xmtbuf[_serial2_offsetxmttail]              -- next byte to xmit
         _serial2_offsetxmttail = _serial2_offsetxmttail + 1      -- next position
         if (_serial2_offsetxmttail >= SERIAL2_XMTBUFSIZE) then   -- end of buffer reached
            _serial2_offsetxmttail = 0                            -- wrap
         end if
         TXREG2 = x                                               -- actually xmit byte
      else                                                        -- xmit buffer empty
         SERIAL2_TXIE2 = DISABLED                                 -- disable xmit interrupts
      end if
   end if

end procedure


-- ----------------------------------------------------------------------
-- Title:     USART serial receive interrupt handler
-- Arguments: (none)
-- Returns:   (nothing)
-- Notes:     Sets CTS low when receive buffer has less than
--            <SERIAL2_DELTA> bytes free space.
-- ----------------------------------------------------------------------
procedure  _serial2_receive_interrupt_handler() is

   pragma interrupt

   var  byte  x

   if  (SERIAL2_RCIF2 == TRUE)  then            -- UART2 receive interrupt

      if ((RCSTA2_OERR == TRUE) | (RCSTA2_FERR == TRUE)) then  -- frame/overr error
         x = RCREG2                             -- flush hardware buffer
         while RCSTA2_OERR == TRUE loop         -- overrun state
            RCSTA2_CREN = FALSE                 -- disable UART
            RCSTA2_CREN = TRUE                  -- re-enable UART
            x = RCREG2                          -- \  flush hardware buffers
            x = RCREG2                          -- /
         end loop                               -- until no more overrun
         _serial2_offsetrcvtail = 0             -- \  flush circular buffer
         _serial2_offsetrcvhead = 0             -- /
         if defined(serial2_ctsinv) then
            serial2_ctsinv = FALSE              -- set CTS true
         end if

      else                                      -- data without errors
         _serial2_rcvbuf[_serial2_offsetrcvhead] = RCREG2      -- move byte to rcv buffer

         if (defined(serial2_receive_wedge) == TRUE) then
            -- receive wedge - a user program can define this procedure.
            --
            --    procedure serial_receive_wedge(byte in char)
            --
            -- If this procedure exisits, it will be called from the
            -- isr, each time a char is received and put into the rx queue.
            --
            -- serial_receive_wedge is used in test_queue_isr.jal
            -- In general it can be usefull to detect ctrl-c or alike when they
            -- arive at the pic (and not when you are ready to process them).
            --
            -- CAUTION: the wedge is part of the ISR and should be designed
            -- to behave accordingly (fast, minimal stack use and nonblocking).
            -- If you are not sure you need this, you probably don't!
            serial2_receive_wedge(_serial2_rcvbuf[_serial2_offsetrcvhead])
         end if

         x = _serial2_offsetrcvhead + 1         -- update offset
         if x >= SERIAL2_RCVBUFSIZE then        -- end of buffer reached
            x = 0                               -- wrap
         end if
         if (x != _serial2_offsetrcvtail) then  -- buffer not yet full
            _serial2_offsetrcvhead = x          -- update offset
         end if                                 -- (else discard byte,
                                                --  CTS flow control has failed)

         if defined(serial2_ctsinv) then
            if (serial2_ctsinv == FALSE) then   -- CTS is TRUE
               if _serial2_offsetrcvhead > _serial2_offsetrcvtail then  -- offset difference
                  x = SERIAL2_RCVBUFSIZE - _serial2_offsetrcvhead + _serial2_offsetrcvtail
               else
                  x = _serial2_offsetrcvtail - _serial2_offsetrcvhead
               end if
               if (x < SERIAL2_DELTA) then      -- circular buffer almost full
                  serial2_ctsinv = TRUE         -- set CTS FALSE
               end if
            end if
         end if
      end if

   end if

end procedure


-- ----------------------------------------------------------------------
-- Title:     Return byte (if any) from circular receive buffer of USART
-- Arguments: received byte (if any)
-- Returns:   - TRUE  when byte returned
--            - FALSE if no byte available
-- Notes:     Sets CTS high when receive buffer has more than <SERIAL2_DELTA>
--            bytes free space after delivering byte to caller.
-- ----------------------------------------------------------------------
function serial_hw2_read(byte out data) return bit is

   var  byte  x                                 -- for buffer management

   if (_serial2_offsetrcvtail == _serial2_offsetrcvhead) then  -- receive buffer empty
      return FALSE                              -- no data available
   end if

   data = _serial2_rcvbuf[_serial2_offsetrcvtail]  -- first available byte
   _serial2_offsetrcvtail = _serial2_offsetrcvtail + 1
   if (_serial2_offsetrcvtail >= SERIAL2_RCVBUFSIZE) then  -- end of buffer reached
      _serial2_offsetrcvtail = 0                 -- wrap
   end if
   if defined(serial2_ctsinv) then
      if (serial2_ctsinv == TRUE) then           -- CTS is FALSE
         if (_serial2_offsetrcvhead > _serial2_offsetrcvtail) then
            x = SERIAL2_RCVBUFSIZE - _serial2_offsetrcvhead + _serial2_offsetrcvtail
         else
            x = _serial2_offsetrcvtail - _serial2_offsetrcvhead  -- offset difference
         end if
         if (x >= SERIAL2_DELTA) then            -- enough free space now
            serial2_ctsinv = FALSE               -- make CTS TRUE
         end if
      end if
   end if

   return TRUE                                  -- byte available

end function


-- ----------------------------------------------------------------------
-- Title:     Put a single byte in transmit buffer
-- Arguments: Data (byte) to transmit
-- Returns:   transmitted byte (or 0x00 when data discarded)
-- Notes:     - Activates transmit interrupt handler when data buffered
--            - When buffer full act as indicated in 'serial2_overflow_discard'
--              * TRUE:  discard data (and return 0x00 as data byte)
--              * FALSE: wait for free buffer space
--                       (returns only after data has been stored in buffer)
-- ----------------------------------------------------------------------
function  serial2_send_byte(byte in data) return byte is

   var  byte  newxmthead                        -- offset in circular buffer

   if (_serial2_offsetxmthead == _serial2_offsetxmttail  &  -- nothing buffered
        SERIAL2_TXIF2 == TRUE) then             -- and UART not busy
      SERIAL2_TXIE2 = DISABLED                  -- disable xmt interrupt
      TXREG2 = data                             -- transmit byte immediately
   else                                         -- use circular buffer
      _serial2_xmtbuf[_serial2_offsetxmthead] = data  -- put byte in buffer
      newxmthead = _serial2_offsetxmthead + 1   -- offset next char
      if (newxmthead >= SERIAL2_XMTBUFSIZE) then  -- end of buffer reached
         newxmthead = 0                         -- wrap
      end if
      if (newxmthead != _serial2_offsetxmttail) then  -- buffer not full
         _serial2_offsetxmthead = newxmthead    -- update offset
      else                                      -- buffer full!
         if (serial2_overflow_discard == FALSE) then  -- do not discard data!
            while (newxmthead == _serial2_offsetxmttail) loop   -- buffer full
               -- nothing                       -- spin until something xmit'd
            end loop
            _serial2_offsetxmthead = newxmthead -- update offset
         else
            data = 0x00                         -- indicate byte discarded
         end if
      end if
      SERIAL2_TXIE2 = ENABLED                   -- (re-)enable xmit interrupts
   end if

   return data                                  -- transmitted byte!

end function


-- ----------------------------------------------------------------------
-- Title:     Get free space in transmit buffer
-- Arguments: (none)
-- Returns:   Number of free bytes in transmit buffer
-- Notes:     - Useful to check in advance if a string will fit in the buffer
--              or if transmitting the string will block.
--            - Never returns zero. If "1" is returned, regard buffer as full.
-- ----------------------------------------------------------------------
function  serial_hw2_tx_buffer_free() return byte is

   var  byte  buffer_free

   buffer_free = _serial2_offsetxmttail - _serial2_offsetxmthead    -- difference
                                                -- between head and tail pointers
      if (_serial2_offsetxmttail <= _serial2_offsetxmthead) then  -- adjust when free
                                                -- space crosses end-of-buffer boundary
         buffer_free = buffer_free + SERIAL2_XMTBUFSIZE           -- or buffer is empty
      end if

   return buffer_free

end function


-- ----------------------------------------------------------------------
-- Title:     Put a single byte in transmit buffer
-- Arguments: Data (byte) to transmit
-- Returns    (nothing)
-- Notes:     - This is a variant of serial2_send_byte() compatible with
--              the procedure in the serial_hardware2 library.
--            - Spins when byte cannot be put in transmit buffer
--              (buffer full condition).
-- ----------------------------------------------------------------------
procedure serial_hw2_write(byte in data) is
   var byte dummy
   dummy = serial2_send_byte(data)
end procedure


-- ----------------------------------------------------------------------
-- Title:     Initialize second serial port
-- Arguments: (none)
-- Returns:   (nothing)
-- ----------------------------------------------------------------------
procedure serial_hw2_init() is

   _serial2_offsetxmthead  = 0                  -- offset next byte from appl
   _serial2_offsetxmttail  = 0                  -- offset next byte to port
   _serial2_offsetrcvhead  = 0                  -- offset next byte from port
   _serial2_offsetrcvtail  = 0                  -- offset next byte to appl

   TXSTA2                  = 0b0000_0000        -- reset (8 databits, asyn)
   RCSTA2                  = 0b0000_0000        -- reset (8 databits, asyn)

   _calculate_and_set_baudrate2()               -- set baudrate and control bits

   pin_RX2_direction       = INPUT              -- make receive pin input
   pin_TX2_direction       = INPUT              -- make transmit pin input!

   TXSTA2_TXEN             = ENABLED            -- enable transmit (makes TX2 pin output)

   RCSTA2_SPEN             = ENABLED            -- activate serial port
   RCSTA2_CREN             = ENABLED            -- continuous receive enable

   SERIAL2_RCIE2           = ENABLED            -- USART receive int. enable
                                                -- (TXIE2 handled dynamically)
   INTCON_PEIE             = ENABLED            -- peripheral interrupts
   INTCON_GIE              = ENABLED            -- general interrupts

   if defined(serial2_ctsinv) then
      serial2_ctsinv       = FALSE              -- CTS true: accept PC data
   end if

end procedure


-- ----------------------------------------------------------------------
-- serial2_hardware compatible interface
-- ----------------------------------------------------------------------

-- Put byte in transmit buffer as pseudo variable
procedure serial_hw2_data'put(byte in data) is
   var byte dummy
   dummy = serial2_send_byte(data)              -- send data
end procedure


-- Return next byte from receive buffer as pseudo variable
-- Spin as long as no data available (buffer empty)
function serial_hw2_data'get() return byte is
   var byte data
   while !serial_hw2_read(data) loop
      -- nothing
   end loop
   return data                                  -- return received data
end function

